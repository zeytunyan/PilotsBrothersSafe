# PilotsBrothersSafe

Реализация на C# головоломки, представленной в компьютерной игре-квесте "Братья пилоты".

В данной реализации поле может принимать разные размеры, от 3x3 до 10x10 (в оригинале было 4x4).



## Правила

Цель игры - открыть сейф.

На сейфе множество рукояток, расположенных квадратом, как 2-мерный массив NxN.

Кликом мышки меняется положение рукоятки с вертикального в горизонтальное и обратно.

При повороте рукоятки поворачиваются все рукоятки в одной строке и в одном столбце. 

Сейф открывается, только если удается расположить все рукоятки параллельно друг другу (т.е. все вертикально или все горизонтально).

![image](https://user-images.githubusercontent.com/47988040/212961597-89662fa0-dbb6-4f7a-8ff8-a78c772eb1bd.png)



## Подсказка

Если самостоятельно решить не получается, можно воспользоваться подсказкой и показать решение, нажав кнопку Solve. 

Отображаемое решение динамически изменяется и не является единственно верным, но вполне может быть самым коротким.

![image](https://user-images.githubusercontent.com/47988040/212959649-51792de6-a06e-4465-a5cf-2d2b0b316a25.png)



## Факты о решении

* Каждый поворот ручки имеет смысл не более одного раза (если ручка поворачивается дважды - она просто возвращается в исходное положение).
* Порядок поворотов не важен, для каждой ручки важно только то, сколько раз она была повернута. Для данной ручки любой поворот любой другой ручки либо поворачивает данную, либо не затрагивает её, и, поскольку ручка может иметь только два положения, неважно, в какой последовательности были произведены повороты, важно лишь их количество (чётно оно или нечетно). 
* Если есть выигрышная комбинация ручек, которые надо повернуть, то комбинация всех ручек, не входящих в выигрышную комбинацию, также является выигрышной. Это вытекает из того факта, что все ручки в конечном итоге могут находиться как в вертикальном, так и в горизонтальном положении.
* Из вышесказанного следует, что при любой конфигурации поля головоломку можно решить не более чем за N<sup>2</sup>/2 ходов.
* Для нечетных N при определенных конфигурациях поля не существует решения. Для четных N решение есть всегда (в данной реализации игры поле может принимать только такие конфигурации, для которых есть решение).



## Лайфхаки

Существует ряд полезных приемов, облегчающих решение головоломки:
* Если выбрать на поле прямоугольную область из ручек и повернуть каждую ручку, находящуюся в углу этой области - изменятся только ручки, которые были нажаты, все остальные ручки останутся в прежнем положении.
* Если повернуть каждую ручку на диагонали, повернутся только эти (лежащие на диагонали) ручки, все остальные останутся в исходном положении.
* Если повернуть каждую ручку в какой-либо строке или столбце, то, если N четно, все ручки, кроме тех, что находятся на данной строке/столбце, изменят свое положение на противоположное. Если же N нечетно, то изменят свое положение на противоположное вообще все ручки на поле .
* Для четных полей существует способ изменить положение только одной конкретной ручки так, чтобы остальные ручки не изменились: для этого нужно повернуть все ручки, которые находятся в той же строке и столбце, что и данная. Это свойство четных полей является основой для одного из алгоритмов решения, о которых пойдет речь ниже.
* Для нечетных N есть следующее интересное свойство: если выбрать в какой-нибудь строке или столбце определенные ручки (назовем их выбранными, а те, что выбраны не были - оставшимися), и повернуть их, то это произведет на поле эффект, в точности противоположный эффекту, производимому поворотом оставшихся ручек. Это свойство позволяет "сокращать" комбинации решений, находя в них последовательности из выбранных ручек и заменяя на более короткие последовательности оставшихся ручек.  



## Алгоритмы решения

Есть несколько общеизвестных алгоритмов решения головоломки:

1. Для четных полей можно изменить положение определенных ручек, просто повернув все ручки в соответствующих столбце и строке. Тем самым легко для любой ручки получить желаемое положение и выиграть.
2. Изначально, не делая никаких ходов, запомнить все ручки, находившиеся в нежелательном положении, после чего поворачивать их, игнорируя текущее состояние поля. Проделывать эти операции снова до тех пор, пока все ручки не окажутся в одинаковом положении.
3. Для каждой ручки подсчитать число тех ручек в её столбце и строке, которые находятся в нежелательном для нас положении, при этом не учитывая саму эту ручку, находящуюся, соответственно, на пересечении этой строки и столбца. Затем повернуть все ручки, для которых получилось нечетное число. 
  


## Аспекты реализации

Чтобы для любой конфигурации поля найти решение или убедиться в его отсутствии с математической точки зрения, правильнее всего, вероятно, было бы решать СЛАУ по модулю 2 (в матпакете Maple, например, реализована такая функция - Linsolve() mod 2). Однако это непросто, и в данной реализации, для генерации рандомных полей, гарантированно имеющих решение, используется другой, более оптимальный, метод. Из уже решенного поля, путем применения к нему случайных ходов (т.е. поворота всех ручек в столбце и строке) получается другое поле, которое, с одной стороны, является запутанным, а с другой - может быть решено, поскольку решить его можно хотя бы просто произведя те же самые ходы, применение которых и позволило это поле получить (т.е. возвратив его в исходное выигрышное положение).

Случайные ходы, применяемые к запутываемому при начале игры выигрышному полю, отбраковываются, если в их столбце или строке уже сделано более, чем N/2 таких ходов. Это, в первую очередь, актуально для полей с нечетными размерами N, потому что таким образом решение для них делается более оптимальным. Для четных полей это тоже включено "для красоты", чтобы не раздражать пользователя необходимостью кликать по большому количеству рукояток в одной строке или столбце.

Данная реализация устроена так, что может работать не только для полей с размером N < 11, но и для вообще любого N, а также при соотношении сторон поля не только NxN, но и MxN. Пользователю демонстрируются только наиболее адекватные размеры и соотношения сторон поля.

Сделано две версии класса GameRealization. В первой конфигурация поля и решение представлены в виде bool-массивов, а для того, чтобы производить те или иные их преобразования, применяются циклы. Во второй используются ulong - числа, биты которых отражают позиции рукояток на поле и наличие/отсутствие ходов в решении, а преобразования производятся с помощью побитовых операций. Версия с ulong-числами более сложна для восприятия, в ней труднее оптимизировать подсказку, а используемые в ней представления в виде ulong-чисел приходится преобразовывать в массивы, чтобы интерфейсу удобно было работать с ними. В то же время, она позволяет использовать элегантные побитовые операции вместо циклов, заранее высчитав необходимые числа, соответствующие, например, ходам, и не проходить затем каждый раз массивы, чтобы сделать то или иное преобразование. Во время работы программы эти реализации незаметно для пользователя подменяют друг друга. Так как реализация с ulong-числами не применима к полям с N больше, чем 8 (максимальное количество рукояток - 64, потому что больше нельзя представить с помощью 64-битного типа ulong), если пользователь выбирает в меню N равное 9 или 10, используется версия с массивами, в противном случае - с ulong-числами.
