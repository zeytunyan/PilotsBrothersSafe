# PilotsBrothersSafe

Реализация на C# головоломки, представленной в компьютерной игре-квесте "Братья пилоты".

В данной реализации поле может принимать разные размеры, от 3x3 до 10x10 (в оригинале было 4x4).



## Правила

Цель игры - открыть сейф.

На сейфе множество рукояток, расположенных квадратом, как 2-мерный массив NxN.

Кликом мышки меняется положение рукоятки с вертикального в горизонтальное и обратно.

При повороте рукоятки поворачиваются все рукоятки в одной строке и в одном столбце. 

Сейф открывается, только если удается расположить все рукоятки параллельно друг другу (т.е. все вертикально или все горизонтально).

![image](https://user-images.githubusercontent.com/47988040/193587972-e00fc185-3850-4dff-9cba-458237e9990c.png)



## Подсказка

Если самостоятельно решить не получается, можно воспользоваться подсказкой и показать решение, нажав кнопку Solve. 

Отображаемое решение динамически изменяется и не является единственно верным, но часто, хоть и не всегда, бывает самым коротким.

![Solution_demonstration](https://user-images.githubusercontent.com/47988040/193585157-58efc9a0-63b9-4750-9f2a-85c5ac09bd66.png)



## Факты о решении

* Каждый поворот ручки имеет смысл не более одного раза (если ручка поворачивается дважды - она просто возвращается в исходное положение).
* Порядок поворотов не важен, для каждой ручки важно только то, сколько раз она была повернута. Для данной ручки люобй поворот любой другой ручки либо поворачивает данную, либо не затрагивает её, и, поскольку ручка может иметь только два положения, неважно, в какой последвательности были произведены повороты, важно лишь их количество (чётно оно или нечетно). 
* Если есть выигрышная комбинация ручек, которые надо повернуть, то комбинация всех ручек, не входящих в выигрушную комбинацию, также является выигрышной. Это вытекает из того факта, что все ручки в конечном итоге могут находиться как в вертикальном, так и в горизонтальном положении.
* Из вышесказанного следует, что при любой конфигурации поля головоломку можно решить не более чем за N<sup>2</sup>/2 ходов.
* Для нечетных N при определенных конфигурациях поля не существует решения. Для четных N решение есть всегда (в данной реализации игры поле может принимать только такие конфигурации, для которых есть решение).

## Лайфхаки

Существует ряд полезных приемов, облегчающих решение головоломки:
* Если выбрать на поле прямоугольную область из ручек и повернуть каждую ручку, находящуюся в углу этой области - изменятся только ручки, которые были нажаты, все остальные ручки останутся в прежнем положении.
* Если повернуть каждую ручку на диагонали, повернутся только эти (лежащие на диагонали) ручки, все остальные останутся в исходном положении.
* Если повернуть каждую ручку в какой-либо строке или столбце, то, если N четно, все ручки, кроме тех, что находятся на данной строке/столбце, изменят свое положение на противоположное.
* Для четных полей существует способ изменить положение только одной конкретной ручки так, чтобы остальные ручки не изменились: для этого нужно повернуть все ручки, которые находятся в той же строке и столбце, что и данная. Это свойство четных полей является основой для одного из алгоритмов решения, о которых пойдет речь ниже.



## Алгоритмы решения

Есть несколько общеизвестных алгоритмов решения головоломки:

1. Для четных полей можно изменить положение определенных ручек, просто повернув все ручки в соответствующих столбце и строке. Тем самым легко для любой ручки получить желаемое положение и выиграть.
2. Изначально, не делая никаких ходов, запомнить все ручки, находившиеся в нежелательном положении, после чего поворачивать их, игнорируя текущее состояние поля. Проделывать эти операции снова до тех пор, пока все ручки не окажутся в одинаковом положении.
3. Для каждой ручки подсчитать число тех ручек в её столбце и строке, которые находятся в нежелательном для нас положении, при этом не учитывая саму эту ручку, находящуюся, соответственно, на пересечении этой строки и столбца. Затем повернуть все ручки, для которых получилось нечетное число. 
  


## Дополнительная информация 

Чтобы для любой конфигурации поля найти решение или убедиться в его отсутствии, правильнее всего, с математической точки зрения, вероятно, было бы решать СЛАУ по модулю 2 (в матпакете Maple, например, реализована такая функция - Linsolve() mod 2). Однако это весьма непросто, и в данной реализации, для генерации рандомных полей, гарантированно имеющих решение, используется другой, более оптимальный, метод. Из уже решенного поля, путем применения к нему случайных ходов (т.е. поворота всех ручек в столбце и строке) получается другое поле, которое, с одной стороны, является запутанным, а с другой - может быть решено, поскольку решить его можно хотя бы просто произведя те же самые ходы, применение которых и позволило это поле получить (т.е. возвратив его в исходное выигрышное положение).

Данная реализация устроена так, что, вероятно, может работать не только для полей с размером N до 10, но и для вообще любого размера N > 2, а также при соотношении сторон поля не только NxN, но и MxN. Однако интерфейс не настроен на показ таких нестандартных конфигураций и не позволяет задать необходимые для этого параметры поля. Впрочем, есть возможность задать размеры вручную в коде, для этого нужно изменить только вот этот фрагмент кода в классе GameForm в файле GameForm.cs:

![image](https://user-images.githubusercontent.com/47988040/193696024-31f91f5e-6fb3-43f1-a7e8-47059c9fbf03.png)

Все отработает, но если ручек будет слишком много, приложение будет очень тормозить и придется ждать, пока интерфейс отобразится, а сами ручки будут настолько маленькими, что могут даже вовсе не показаться или быть внешне искажены. Если же поле имеет неравные стороны, ручки на нем будут растянуты. Таким образом, поскольку интерфейс изначально не предназначен для этого, внешний вид будет печальным, но функциональность сохранится, и её можно использовать, например, для какого-то другого интерфейса, поддерживающего такие необычные варианты поля. 









